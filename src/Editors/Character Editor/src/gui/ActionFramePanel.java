/*
 * ActionFramePanel.java
 *
 * Created on 26 November 2008, 15:08
 */

package gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.image.BufferedImage;

import javax.swing.SwingUtilities;

import util.ICoordinatesTaker;
import util.UBPoint;

import frames.Frame;
import java.awt.Cursor;
import java.util.List;
import util.Geom;
import util.IntPoint;

/**
 * Panel that holds a frame, shows it and allows it's mass center manipulation
 * @author  Gil Costa
 */
public class ActionFramePanel extends APanelWithScroll implements MouseMotionListener, MouseListener, ICoordinatesTaker{
    /** default serial ID*/
	private static final long serialVersionUID = 1L;
	
	//---------------------
	// ---- CONSTANTS ----
	//---------------------
	
	protected static final int CM_RADIUS = 9;
	protected static final int CM_SIZE = 2*CM_RADIUS+1;
    protected static final int CATCH_RADIUS = CM_RADIUS*2;
    
    protected static final Color ACTION_COLOR = Color.GREEN;
    protected static final Color SELECTED_ACTION_COLOR = Color.YELLOW;
	
	
	//------------------
	// ---- FIELDS ----
	//------------------
	
	/** the frame to manipulate */
	protected Frame frame;
	protected boolean showCM;
    protected boolean showActionPoints;
    protected List<IntPoint> actionPoints;
    protected int selected;
	
	protected ICoordinatesTaker coordinatesTaker;
    
    protected int DX, DY;
	

	
	
	
	// ----------------------------
	//  ----   CONSTRUCTORS   ----
	// ----------------------------
	/** Creates new form ActionFramePanel */
    public ActionFramePanel(Scroller scroller, ICoordinatesTaker coordinatesTaker) {
    	super(scroller);
    	this.coordinatesTaker = coordinatesTaker;
    	frame = null;
    	showCM = true;
        showActionPoints = true;
        selected = 0;
        DX = DY = 0;
        initComponents();
        this.addMouseListener(this);
        this.addMouseMotionListener(this);
    }
    
    
    
    // -----------------------
	//  ----   SETTERS   ----
	// -----------------------
    /** set frame */
    public void setFrame(Frame f){
    	this.frame = f;
        if (frame == null) return;
    	setTrueWidth(f.getImage().getWidth());
    	setTrueHeight(f.getImage().getHeight());
    	updateSize(-1,-1);
    	repaint();
    }
    
     /** set frame */
    public void setActionPoints(List<IntPoint> points){
        this.actionPoints = points;
        if (frame == null) return;
    	repaint();
    }
    
    /** set CM showing or not */
    public void showCM(boolean show){
    	showCM = show;
    	repaint();
    }
    
    public void showActionPoints(boolean action){
    	showActionPoints = action;
    }
    
    // -----------------------
	//  ----   GETTERS   ----
	// -----------------------
    public Frame getFrame(){
    	return frame;
    }
    
    public List<IntPoint> getPoints(){ return actionPoints; }
    
    
    
    
    protected int catched(int x, int y){
        if (actionPoints==null) return -1;
        for(int i=0; i<actionPoints.size(); i++){
            IntPoint p = actionPoints.get(i);
            if (p==null) continue;
            int cx = (int)((frame.getCM().getX()+ p.getX())*scaleFactor+(0.5*scaleFactor));
            int cy = (int)((frame.getCM().getY()+ p.getY())*scaleFactor+(0.5*scaleFactor));
            if (Geom.distanceBetween(cx, cy, x, y) < CATCH_RADIUS)
                return i;
        }
        return -1;
    }
    
    
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 200, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 200, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents



	
	
	// -----------------------------------
	//  ------   MOUSE LISTENERS   ------
	// -----------------------------------
    
    //____________________
    // ---- DRAGGING ----
	@Override
	public void mouseDragged(MouseEvent e) {
		if (frame == null || !SwingUtilities.isLeftMouseButton(e)) return;
        int mouseX = e.getX()-DX;
        int mouseY = e.getY()-DY;
		//int mouseX = Math.min(Math.max(0, e.getX()), (int)((frame.getImage().getWidth()-1)*scaleFactor));
		//int mouseY = Math.min(Math.max(0, e.getY()), (int)((frame.getImage().getHeight()-1)*scaleFactor));
        if (selected == -1 || actionPoints == null || actionPoints.get(selected) == null) return;
        int oldX = frame.getCM().getX()+actionPoints.get(selected).getX();
        int oldY = frame.getCM().getY()+actionPoints.get(selected).getY();
        actionPoints.get(selected).set((int)((mouseX/scaleFactor)-frame.getCM().getX()),(int)((mouseY/scaleFactor)-frame.getCM().getY()));
        repaintCursor(oldX,oldY);
        final int newX = frame.getCM().getX()+actionPoints.get(selected).getX();
        final int newY = frame.getCM().getY() + actionPoints.get(selected).getY();
        repaintCursor(newX,newY);
        coordinatesTaker.takeCoordinates(actionPoints.get(selected).getX(),actionPoints.get(selected).getY(), selected);
	}
	
	
	@Override public void mouseReleased(MouseEvent e) {	}
	@Override public void mouseEntered(MouseEvent e) { }
	@Override public void mouseExited(MouseEvent e) { }
	@Override public void mouseMoved(MouseEvent e) {
        int mouseX = e.getX() - DX;
        int mouseY = e.getY() - DY;
        if (catched(mouseX,mouseY)!=-1)
             setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        else setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    }
	@Override
	public void mouseClicked(MouseEvent e) { }
	@Override
	public void mousePressed(MouseEvent e) {
        int mouseX = e.getX() - DX;
        int mouseY = e.getY() - DY;
        int tryCatch = catched(mouseX,mouseY);
        if (tryCatch != -1){
            selected = tryCatch;
            coordinatesTaker.takeCoordinates(
                (int)(mouseX/scaleFactor - frame.getCM().getX()),
                (int)(mouseY/scaleFactor - frame.getCM().getY()),
                selected
            );
            repaint();
        }
    }
  
	
	
	
	
	
	
	
	// -----------------------
	//  ----   REPAINT   ----
	// -----------------------
    public void repaintAction(){
        for(IntPoint p:actionPoints){
            repaintCursor(p.getX(), p.getY());
        }
    }
    public void repaintCM(){
    	int x = frame.getCM().getX();
		int y = frame.getCM().getY();
		repaintCursor(x, y);
    }
    protected void repaintCursor(int x, int y){
		repaint(new Rectangle(DX + (int)(x*scaleFactor+(0.5*scaleFactor))-CM_RADIUS,DY + (int)(y*scaleFactor+(0.5*scaleFactor))-CM_RADIUS,CM_SIZE,CM_SIZE));
    }
    
    
    
    protected void drawCross(Graphics g, int cx, int cy, Color c){
        cx+=DX;
        cy+=DY;
        g.setColor(Color.BLACK);
        g.drawOval(cx-CM_RADIUS, cy-CM_RADIUS, CM_RADIUS*2, CM_RADIUS*2);
        g.drawOval(cx-CM_RADIUS+2, cy-CM_RADIUS+2, CM_RADIUS*2-4, CM_RADIUS*2-4);
        g.drawLine(cx-CM_RADIUS, cy-1, cx-1, cy-1);
        g.drawLine(cx+CM_RADIUS, cy+1, cx+1, cy+1);
        g.drawLine(cx-1, cy-CM_RADIUS, cx-1, cy-1);
        g.drawLine(cx+1, cy+CM_RADIUS, cx+1, cy+1);
        g.setColor(c);
        g.drawOval(cx-CM_RADIUS+1, cy-CM_RADIUS+1, CM_RADIUS*2-2, CM_RADIUS*2-2);
         g.drawLine(cx-CM_RADIUS, cy, cx-1, cy);
         g.drawLine(cx+CM_RADIUS, cy, cx+1, cy);
         g.drawLine(cx, cy-CM_RADIUS, cx, cy-1);
         g.drawLine(cx, cy+CM_RADIUS, cx, cy+1);
    }
    
    
	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		if (frame == null) return;
		BufferedImage img = frame.getImage();
		if (img!=null){
			int imgW = (int)(img.getWidth()*scaleFactor);
			int imgH = (int)(img.getHeight()*scaleFactor);
            
            DX = Math.max((this.getWidth()-imgW)/2,0);
            DY = Math.max((this.getHeight()-imgH)/2,0);
            
            g.setColor(Color.BLACK);
            g.drawRect(DX, DY, imgW, imgH);
			g.drawImage(img, DX,DY,imgW, imgH,this);
            if (showCM){
                int cx = (int)(frame.getCM().getX()*scaleFactor+(0.5*scaleFactor));
                int cy = (int)(frame.getCM().getY()*scaleFactor+(0.5*scaleFactor));
                // draw CM
                drawCross(g,cx,cy, Color.WHITE);
            }
            if (showActionPoints && actionPoints!=null){
                for(int i=0; i<actionPoints.size(); i++){
                    IntPoint p = actionPoints.get(i);
                    if (p== null) continue;
                    if (i == selected) g.setColor(SELECTED_ACTION_COLOR);
                    int cx = (int)((frame.getCM().getX() + p.getX())*scaleFactor+(0.5*scaleFactor));
                    int cy = (int)((frame.getCM().getY() + p.getY())*scaleFactor+(0.5*scaleFactor));
                    // draw point
                    drawCross(g,cx,cy, ACTION_COLOR);
                }
            }
		}
		
	}

    public void takeCoordinates(int x, int y, int index) {
        selected = index;
        repaint();
    }


    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}
