/*
 * ActionFramePanel.java
 *
 * Created on 26 November 2008, 15:08
 */

package gui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.image.BufferedImage;


import util.ICoordinatesTaker;

import frames.Frame;
import java.awt.Cursor;
import util.IColorTaker;
import util.IntPoint;

/**
 * Panel that holds a frame, shows it and allows it's mass center manipulation
 * @author  Gil Costa
 */
public class FramePanel extends APanelWithScroll implements MouseMotionListener, MouseListener, ICoordinatesTaker{
    /** default serial ID*/
	private static final long serialVersionUID = 1L;
	
	//---------------------
	// ---- CONSTANTS ----
	//---------------------
	
	protected static final int CM_RADIUS = 9;
	protected static final int CM_SIZE = 2*CM_RADIUS+1;
    protected static final int CATCH_RADIUS = CM_RADIUS*2;
    
    protected static final Color ACTION_COLOR = Color.GREEN;
    protected static final Color SELECTED_ACTION_COLOR = Color.YELLOW;
	
	
	//------------------
	// ---- FIELDS ----
	//------------------
	
	/** the frame to manipulate */
	protected Frame frame;
	protected boolean showCM;
    protected boolean pickingColor;
	
	protected ICoordinatesTaker coordinatesTaker;
	protected IColorTaker colorTaker;
    
    protected int DX, DY;
	

	
	
	
	// ----------------------------
	//  ----   CONSTRUCTORS   ----
	// ----------------------------
	/** Creates new form ActionFramePanel */
    public FramePanel(Scroller scroller, ICoordinatesTaker coordinatesTaker, IColorTaker colorTaker) {
    	super(scroller);
    	this.coordinatesTaker = coordinatesTaker;
    	this.colorTaker = colorTaker;
    	frame = null;
    	showCM = true;
        DX = DY = 0;
        initComponents();
        this.addMouseListener(this);
        this.addMouseMotionListener(this);
    }
    
    
    
    // -----------------------
	//  ----   SETTERS   ----
	// -----------------------
    /** set frame */
    public void setFrame(Frame f){
    	this.frame = f;
        if (frame == null) return;
    	setTrueWidth(f.getImage().getWidth());
    	setTrueHeight(f.getImage().getHeight());
    	updateSize(-1,-1);
    	repaint();
    }
    
    
    /** set CM showing or not */
    public void showCM(boolean show){
    	showCM = show;
    	repaint();
    }
    
    public void pickColor(boolean pick){
    	pickingColor = pick;
    }
    
    
    // -----------------------
	//  ----   GETTERS   ----
	// -----------------------
    public Frame getFrame(){
    	return frame;
    }
    

        
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 200, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 200, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents



	
	
	// -----------------------------------
	//  ------   MOUSE LISTENERS   ------
	// -----------------------------------
    
    //____________________
    // ---- DRAGGING ----
	@Override
	public void mouseDragged(MouseEvent e) {
		mousePressed(e);
	}
	
	
	@Override public void mouseReleased(MouseEvent e) {	}
	@Override public void mouseEntered(MouseEvent e) { }
	@Override public void mouseExited(MouseEvent e) { }
	@Override
    public void mouseMoved(MouseEvent e) {
        if(pickingColor) setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
        else setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    }
	@Override public void mouseClicked(MouseEvent e) { }
	@Override
	public void mousePressed(MouseEvent e) {
        int mouseX = e.getX() - DX;
        int mouseY = e.getY() - DY;
        if (pickingColor && colorTaker!=null){
            int tmpX = (int)(mouseX/scaleFactor);
            int tmpY = (int)(mouseY/scaleFactor);
            if (tmpX>=0 && tmpX <frame.getImage().getWidth()
                && tmpY>=0 && tmpY <frame.getImage().getHeight())
            {
                colorTaker.takeColor(new Color(frame.getImage().getRGB(tmpX, tmpY)));
            }
		}
		else if (showCM){
            int x = frame.getCM().getX();
			int y = frame.getCM().getY();
			frame.setCM(new IntPoint((int)(mouseX/scaleFactor),(int)(mouseY/scaleFactor)));
			coordinatesTaker.takeCoordinates(-1, frame.getCM().getX(), frame.getCM().getY());
			repaintCursor(x,y);	// clear last CM position
			repaintCM();		// paint its new position
        }
    }
  
	
	
	
	
	
	
	
	// -----------------------
	//  ----   REPAINT   ----
	// -----------------------
    public void repaintCM(){
    	int x = frame.getCM().getX();
		int y = frame.getCM().getY();
		repaintCursor(x, y);
    }
    protected void repaintCursor(int x, int y){
		repaint(new Rectangle(DX + (int)(x*scaleFactor+(0.5*scaleFactor))-CM_RADIUS,DY + (int)(y*scaleFactor+(0.5*scaleFactor))-CM_RADIUS,CM_SIZE,CM_SIZE));
    }
    
    
    
    protected void drawCross(Graphics g, int cx, int cy, Color c){
        cx+=DX;
        cy+=DY;
        g.setColor(Color.BLACK);
        g.drawOval(cx-CM_RADIUS, cy-CM_RADIUS, CM_RADIUS*2, CM_RADIUS*2);
        g.drawOval(cx-CM_RADIUS+2, cy-CM_RADIUS+2, CM_RADIUS*2-4, CM_RADIUS*2-4);
        g.drawLine(cx-CM_RADIUS, cy-1, cx-1, cy-1);
        g.drawLine(cx+CM_RADIUS, cy+1, cx+1, cy+1);
        g.drawLine(cx-1, cy-CM_RADIUS, cx-1, cy-1);
        g.drawLine(cx+1, cy+CM_RADIUS, cx+1, cy+1);
        g.setColor(c);
        g.drawOval(cx-CM_RADIUS+1, cy-CM_RADIUS+1, CM_RADIUS*2-2, CM_RADIUS*2-2);
         g.drawLine(cx-CM_RADIUS, cy, cx-1, cy);
         g.drawLine(cx+CM_RADIUS, cy, cx+1, cy);
         g.drawLine(cx, cy-CM_RADIUS, cx, cy-1);
         g.drawLine(cx, cy+CM_RADIUS, cx, cy+1);
    }
    
    
	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		if (frame == null) return;
		BufferedImage img = frame.getImage();
		if (img!=null){
			int imgW = (int)(img.getWidth()*scaleFactor);
			int imgH = (int)(img.getHeight()*scaleFactor);
            
            DX = Math.max((this.getWidth()-imgW)/2,0);
            DY = Math.max((this.getHeight()-imgH)/2,0);
            
            g.setColor(Color.BLACK);
            g.drawRect(DX, DY, imgW, imgH);
			g.drawImage(img, DX,DY,imgW, imgH,this);
            if (showCM){
                int cx = (int)(frame.getCM().getX()*scaleFactor+(0.5*scaleFactor));
                int cy = (int)(frame.getCM().getY()*scaleFactor+(0.5*scaleFactor));
                // draw CM
                drawCross(g,cx,cy, Color.WHITE);
            }
		}
		
	}

    public void takeCoordinates(int x, int y, int index) {
        repaint();
    }


    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}
